# -*- coding: utf-8 -*-
"""Independent OTT Backend (app.py)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19Kb9VNR97kBNDUwPwDBAf-n77Hjxort9
"""

import os
import json
import subprocess
from flask import Flask, request, jsonify, send_from_directory, Response

# --- Configuration ---
# Directory to store movie files
MOVIE_DIR = os.path.expanduser("~/ott_movies")
# Database file to store movie metadata
DB_FILE = os.path.join(MOVIE_DIR, "movies.json")
# Create the movie directory if it doesn't exist
os.makedirs(MOVIE_DIR, exist_ok=True)

app = Flask(__name__, static_folder=MOVIE_DIR, static_url_path='/media')

# --- Database Helper Functions ---
def get_movie_db():
    """Reads the movie database from the JSON file."""
    if not os.path.exists(DB_FILE):
        return []
    with open(DB_FILE, 'r') as f:
        return json.load(f)

def save_movie_db(db):
    """Saves the movie database to the JSON file."""
    with open(DB_FILE, 'w') as f:
        json.dump(db, f, indent=4)

# Initialize DB file if it doesn't exist
if not os.path.exists(DB_FILE):
    save_movie_db([])

# --- Frontend Routes ---
@app.route('/')
def player_page():
    """Serves the main player gallery page."""
    return send_from_directory('.', 'index.html')

@app.route('/admin')
def admin_page():
    """Serves the admin panel for adding movies."""
    # We will use the existing 'ott-admin-panel' html, but rename it to admin.html
    return send_from_directory('.', 'admin.html')

# --- API Routes ---
@app.route('/movies')
def get_movies():
    """API endpoint to get the list of all movies."""
    movies = get_movie_db()
    return jsonify(movies)

@app.route('/add_movie', methods=['POST'])
def add_movie():
    """API endpoint to add a new movie from a URL."""
    data = request.get_json()
    url = data.get('url')

    if not url:
        return jsonify({'error': 'URL is required'}), 400

    try:
        # Use yt-dlp to get the title and generate a safe filename
        # This command just gets the prospective filename without downloading
        get_filename_cmd = ['yt-dlp', '--get-filename', '-o', '%(title)s.%(ext)s', url]
        filename_bytes = subprocess.check_output(get_filename_cmd)
        filename = filename_bytes.decode('utf-8').strip()
        title = os.path.splitext(filename)[0]

        # Check if movie already exists
        db = get_movie_db()
        if any(m['filename'] == filename for m in db):
            return jsonify({'message': 'Movie already exists in the library.'}), 200

        # Add movie to DB first, so it appears in the UI as "downloading"
        db.append({'title': title, 'filename': filename, 'status': 'downloading'})
        save_movie_db(db)

        # Start the actual download in the background
        download_cmd = ['yt-dlp', '-o', os.path.join(MOVIE_DIR, filename), url]

        # Using Popen for a non-blocking download process
        process = subprocess.Popen(download_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        # In a real app, you'd have a worker update the status upon completion.
        # For this simple example, we will just start it. A more robust solution
        # would be to check process.poll() later.

        return jsonify({'message': f'Download started for: {title}'}), 202

    except subprocess.CalledProcessError as e:
        return jsonify({'error': f"Failed to get movie info: {e.stderr.decode('utf-8')}"}), 500
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# --- Video Streaming Route ---
@app.route('/video/<path:filename>')
def stream_video(filename):
    """Serves the video files for streaming."""
    return send_from_directory(MOVIE_DIR, filename)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)